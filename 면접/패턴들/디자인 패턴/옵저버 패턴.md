---
tags:
  - Design-Pattern
---
옵저버 패턴을 사용하면 애플리케이션의 일부를 관찰하여 한 부분이 변경되면 해당 부분에 의존하는 다른 모든 부분이 자동으로 업데이트 되도록 할 수 있습니다. 

예를 들어, 뉴스레터를 구독하는 것처럼 앱의 다양한 부분이 다른 부분을 <mark style="background: #ADCCFFA6;">구독</mark>할 수 있는 구독 시스템을 정의할 수 있습니다. 구독 중인 부분(뉴스레터)에 변경 사항이 있으면 모든 구독자에게 자동으로 변경 사항에 대한 알림이 전송됩니다. 이렇게 하면 공유할 새로운 내용이 있을 때마다 메일함에 새 버전의 뉴스레터가 수신되는 것과 마찬가지로 앱 구성 요소가 계속 업데이트됩니다.

옵저버 패턴은 특정 객체를 구독할 수 있는데, 구독하는 주체를 `Observer`라 하고. 구독 가능한 객체를 `Observable`이라 합니다. 이벤트가 발생할 때 마다 `Observable`은 모든 `Observer`에게 <mark style="background: #ADCCFFA6;">이벤트를 전파</mark>합니다. 여기서 `Observable`는 우리가 관심 있는 클래스이고, `Observer`는 객체를 관찰하는 클래스라고 생각하면 됩니다. 

### 특징
`Observable`객체는 보통 3가지 주요 특징을 포함합니다.

- `subscribe()`: `Observer`를 `Observer`배열에 추가합니다.
- `unsubscribe()`: `Observer`배열에서 `Observer`를 제거합니다.
- `notify()`: 등록된 모든 `Observer`들에게 이벤트를 전파합니다.

- `observers`: 이벤트가 발생할 때마다 전파할 `Observer`들의 배열입니다.

### 구현
음악 페스티벌을 상상해 보겠습니다. 여기엔 밴드라는 `Observable`, 많은 `Observers`들(팬들, 보안 요원, 조명 등)이 있을 겁니다. 서로 다른 모든 `Observer`가 구현할 수 있는 인터페이스를 구현해보겠습니다.

위에서 언급했듯이 `Observable` 인터페이스에는 3가지 메서드(subscribe, unsubscribe, notify)가 있어야 합니다.
```typescript
interface Observable {
	// 옵저버 추가
	subscribe: (observer: Observer) => void;
	// 옵저버 제거
	unsubscribe: (observer: Observer) => void;
	// 변경 사항 전파
	notify: (event: string) => void;
}
```

이제 `Observable`(밴드)를 간단히 구현해 보겠습니다. 
```typescript
```



element가 `Observer`가 되려면 **notify**라는 메서드가 있어야 합니다. 그리고 문자열 타입의 `event`를 인수로 받습니다.
```typescript
interface Observer {
	notify: (event: string) => void;
}
```

팬들, 보안 요원, 조명을 `Observer`로 구현한 예제를 보겠습니다.
```typescript
// 팬
Class Fan implements Observer {
	notify(event: string): void {
		if (event === 'START') {
			console.log('환호성');
		} else if (event === 'END') {
			console.log('즐거웠어요');
		}
	}
}

// 보안 요원
Class Security implements Observer {
	notify(event: string): void {
		if (event === 'START') {
			console.log('문 닫기');
		} else if (event === 'END') {
			console.log('문 열기');
		}
	}
}

// 조명
Class Lights implements Observer {
	notify(event: string): void {
		if (event === 'PLAY_SONG') {
			console.log('불이 켜짐')
		}
	}
}
```

### 장점
**옵저버 패턴**을 사용하는 것은 관심사의 분리와 단일 책임의 원칙을 강제하기 위한 좋은 방법입니다. `Observer`객체는 `Observable`객체와 강결합되어있지않고 언제든지 분리될 수 있습니다. `Observable`객체는 이벤트 모니터링의 역할을 갖고, `Observer`는 받은 데이터를 처리하는 역할을 갖게 됩니다.
### 단점
`Observer`가 복잡해지면 모든 `Observer`들에 알림을 전파하는 데 성능 이슈가 발생할 수 있습니다.

---

## 참고
- [패턴즈](https://patterns-dev-kr.github.io/design-patterns/observer-pattern/)
- [노마드코더](https://www.youtube.com/watch?v=bdcxCpB68Xs&ab_channel=%EB%85%B8%EB%A7%88%EB%93%9C%EC%BD%94%EB%8D%94NomadCoders)