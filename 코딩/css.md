---
tags:
  - CSS
---
1. **box model**:
    
    - 모든 HTML 요소는 브라우저에서 상자로 시각화될 수 있습니다. 이 상자는 여백, 테두리, 패딩 및 실제 콘텐츠로 구성됩니다. 요소의 전체 너비와 높이는 이러한 값을 합산하여 계산됩니다. 이를 이해하면 디자이너와 개발자가 레이아웃 동작을 예측하여 적절한 간격과 정렬을 보장하는 데 도움이 됩니다.
2. **box-sizing 속성**:
    
    - `box-sizing: border-box;` 선언은 너비 및 높이 속성이 작동하는 방식을 변경합니다. 콘텐츠의 크기만 설정하는 대신 이제 패딩과 테두리도 포함됩니다. 이렇게 하면 패딩이나 테두리를 추가할 때 요소 크기가 예기치 않게 증가하지 않으므로 레이아웃 계산이 더욱 직관적이 됩니다.
3. **display 속성**:
    
    - `display` 속성은 요소의 표시 유형을 정의합니다.
        
        - `block`: 요소는 상위 요소의 전체 너비를 차지하고 수직으로 쌓입니다.
        - `인라인`: 요소는 필요한 만큼의 너비만 차지하며 강제로 줄바꿈을 하지 않습니다.
        - `inline-block`: 인라인과 블록을 혼합합니다. 요소는 인라인으로 배치될 수 있지만 블록과 같은 속성을 유지합니다.
        - `flex`: 요소를 블록 수준 플렉스 컨테이너로 정의합니다.
        - `grid`: 요소를 블록 수준 그리드 컨테이너로 정의합니다.
        - `none`: 요소가 UI에서 렌더링되지 않습니다.
4. **inline vs inline-block**:
    
    - `인라인`: 요소는 새 줄로 넘어가지 않고 필요한 만큼만 너비를 차지합니다. 너비와 높이를 명시적으로 설정할 수 없습니다.
    - `inline-block`: 흐름 측면에서 인라인 요소처럼 동작하지만 블록 요소의 속성을 유지합니다. 즉, 너비와 높이를 설정할 수 있습니다.
5. **position**:
    
    - `static`: 기본 위치 지정. 요소가 일반적인 문서 흐름에 있습니다.
    - `relative`: 정상 위치를 기준으로 위치 지정됩니다. 이를 오프셋해도 다른 요소에는 영향을 미치지 않습니다.
    - `absolute`: 가장 가까운 위치의 조상을 기준으로 위치 지정됩니다. 일반적인 문서 흐름에서 제거되었습니다.
    - `고정`: 뷰포트를 기준으로 위치가 지정되며 페이지를 스크롤하더라도 같은 위치에 유지됩니다.
6. **Cascading in CSS & cascading system의 장점**:
    
    - 캐스케이딩은 브라우저가 요소에 어떤 스타일을 적용할지 결정하는 프로세스입니다. 스타일은 사용자 에이전트 스타일, 사용자 스타일, 개발자 스타일 등 다양한 소스에서 나올 수 있습니다. 보다 구체적인 스타일이 덜 구체적인 스타일보다 우선하여 구체적인 순서대로 적용됩니다. 장점은 명확한 스타일 계층 구조를 제공하고 스타일 상속을 허용하며 스타일 해결을 위한 일관된 시스템을 제공한다는 것입니다.
7. **CSS 프레임워크**:
    
    - Antd, MUI, Bootstrap 및 Tailwind와 같은 CSS 프레임워크는 사전 디자인된 구성 요소를 제공하여 일관된 모양과 느낌을 보장합니다. 개발 속도를 높이고 즉시 반응하는 디자인을 제공하며 잘 테스트된 브라우저 간 호환성을 제공합니다.
8. **Flexbox & Grid**:
    
    - 둘 다 기존 모델보다 더 깔끔하고 효율적인 방법으로 복잡한 레이아웃 구조를 디자인하기 위한 최신 CSS 사양입니다. 특히 공간을 분배하고 복잡한 레이아웃에서 항목을 정렬할 때, 그리고 항목의 크기를 알 수 없거나 동적일 때 더욱 그렇습니다.
9. **반응형 디자인과 적응형 디자인**:
    
    - **반응형 디자인**: 뷰포트에 따라 늘어나고 줄어드는 유동 그리드를 사용합니다. 다양한 장치에 적용되는 하나의 디자인에 관한 것입니다.
    - **적응형 디자인**: 태블릿, 모바일, 데스크탑과 같은 특정 장치 크기를 대상으로 합니다. 여러 레이아웃이 생성됩니다.
10. **레티나 그래픽**:
    
    - 레티나 그래픽 작업에는 고해상도 이미지나 벡터 그래픽을 사용하여 높은 DPI(인치당 도트 수) 화면의 선명도를 보장하는 작업이 포함됩니다. 높은 DPI 장치를 대상으로 하는 CSS 이미지 스프라이트, SVG 및 미디어 쿼리와 같은 기술을 사용할 수 있습니다.
11. **Translate() vs 절대 ​​좌표**:
    
    - 특히 애니메이션의 경우 `translate()`를 사용하면 절대 위치 지정보다 유리합니다. `translate()`는 GPU를 활용하여 애니메이션을 더 부드럽게 만듭니다. 절대 위치 지정으로 인해 레이아웃이 다시 계산되어 성능이 저하될 수 있습니다. 또한 `translate()`는 요소를 흐름에 유지하여 레이아웃 문제를 줄입니다.
12. **시각적으로 보이지 않고 스크린 리더에서만 가능하게 하는 방법**
    - 요소를 스크린 리더에만 표시하려면 CSS 조합을 사용하여 스크린 리더 기술에 계속 액세스할 수 있도록 하면서 콘텐츠를 시각적으로 숨깁니다. 일반적으로 사용되는 방법:
    ```css
    .screen-reader-only {
	    position: absolute;
	    width: 1px;
	    height: 1px;
	    padding: 0;
	    margin: -1px;
	    overflow: hidden;
	    clip: rect(0, 0, 0, 0);
	    border: 0;
	}
	```
	이 기술은 요소를 시각적으로 숨기지만 화면 판독기가 이를 감지할 수 있도록 DOM에 유지합니다.
13. **그리드 시스템**
    - **CSS Grid**는 2차원 레이아웃에 강력한 반면 **Flexbox**는 1차원 레이아웃에 탁월합니다. Bootstrap과 같은 기존 그리드 시스템은 신속한 프로토타이핑과 광범위한 브라우저 지원을 제공합니다.