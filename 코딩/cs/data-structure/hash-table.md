---
tags:
  - Data-Structure
---
해시 테이블은 해시 함수와 함께 배열을 사용하며 키-값 쌍을 저장할 수 있습니다. 키가 주어지면 **매우 빠른 조회**를 위해 값을 키와 연결하는 방법을 제공합니다. 키를 가져와서 해시 함수를 통해 처리한 다음 빠르게 저장 위치를 결정하거나 이와 관련된 값을 탐색할 수 있습니다.

```block
key  => value lookup
"ai" => new Person(iq=179, name='ben')
"barb" => new Person(q=140, name='hacky')
```

특정한 값을 탐색하는데 데이터 고유의 인덱스로 접근하게 되므로 평균적으로 시간 복잡도는 `O(1)`이 됩니다. 여기서 **평균적으로** O(1)인 것은 `Collision` 때문입니다. `Collision`이 자주 발생한다면 탐색 시간은 O(n)에 가까워지게 됩니다. 속도 이점은 메모리를 희생하면서 발생하는 것인만큼 메모리는 더 많이 사용하는데 시간 복잡도는 같게 되는 비효율적인 상황이 발생하게 됩니다.

**해시 함수**를 통해 고유한 인덱스 값을 설정합니다. 충돌을 최소화하려면 결국 좋은 해시 함수를 만드는 게 중요해 보입니다. 그렇다면 좋은 해시 함수는 어떠한 조건을 갖추어야 할까요?
일반적으로 좋은 해시 함수는 키의 일부분을 참조하여 해시 값을 생성하지 않고 키 전체를 참조해 해시 값을 생성합니다. 

그럼 `Collision`은 왜 발생하게 되는 걸까요? 탐색할 때 데이터 고유의 인덱스로 접근합니다. 이 고유의 인덱스는 해시 함수를 이용해 저장할 데이터와 연관된 고유한 숫자를 만들어 낸 뒤 이를 인덱스로 사용하는 것입니다. 또한 이 고유한 인덱스는 메모리 효율을 위해 **작은 범위의 값**을 가집니다. 작은 범위의 값으로 상당히 큰 배열에 대해 해시 코드를 1:1 대응이 되도록 만들기엔 한계가 있으므로 충돌이 납니다. 그렇다고 1:1 대응이 되도록 해시 함수를 만들어봤자 그건 `array`와 다를바 없고 메모리를 너무 차지하게 됩니다. 그러므로 `Collision` 해결은 필수이며 그 방법들에 대해 알아보겠습니다.

충돌을 해결하는 데 여러 가지 방법이 있습니다. 그 중 기본이 되는 `Open Address`과 `Separate Chaining` 방식에 대해 알아보겠습니다.

