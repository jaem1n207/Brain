---
tags:
  - Data-Structure
---
해시 테이블은 해시 함수와 함께 배열을 사용하며 키-값 쌍을 저장할 수 있습니다. 키가 주어지면 **매우 빠른 조회**를 위해 값을 키와 연결하는 방법을 제공합니다. 키를 가져와서 해시 함수를 통해 처리한 다음 빠르게 저장 위치를 결정하거나 이와 관련된 값을 탐색할 수 있습니다.

```block
key  => value lookup
"ai" => new Person(iq=179, name='ben')
"barb" => new Person(q=140, name='hacky')
```

특정한 값을 탐색하는데 데이터 고유의 인덱스로 접근하게 되므로 평균적으로 시간 복잡도는 `O(1)`이 됩니다. 여기서 **평균적으로** O(1)인 것은 `Collision` 때문입니다. `Collision`이 자주 발생한다면 탐색 시간은 O(n)에 가까워지게 됩니다. 속도 이점은 메모리를 희생하면서 발생하는 것인만큼 메모리는 더 많이 사용하는데 시간 복잡도는 같게 되는 비효율적인 상황이 발생하게 됩니다.

고유한 인덱스 값은 **해시 함수**를 통해 생성됩니다. 그러므로 충돌을 최소화하려면 결국 좋은 해시 함수를 만드는 게 중요해 보입니다. 그렇다면 좋은 해시 함수는 어떠한 조건을 갖추어야 할까요?

일반적으로 좋은 해시 함수는 키의 일부분을 참조하여 해시 값을 생성하지 않고 키가 어떤 특성을 가지고 있느냐에 따라 달라지게 됩니다.

해시 함수를 무조건 1:1로 만드는 것보다 `Collision`을 최소화하는 방향으로 설계하고 발생하는 충돌에 대비해 어떻게 대응할 것인가가 더 중요합니다. 1:1 대응이 되도록 해시 함수를 만들어봤자 그건 `array`와 다를바 없고 메모리를 너무 차지하게 됩니다.

`Collision`은 왜 발생하게 되는 걸까요? 탐색할 때 데이터 고유의 인덱스로 접근합니다. 이 고유의 인덱스는 해시 함수를 이용해 저장할 데이터와 연관된 고유한 숫자를 만들어 낸 뒤 이를 인덱스로 사용하는 것입니다. 또한 이 고유한 인덱스는 메모리 효율을 위해 **작은 범위의 값**을 가집니다. 작은 범위의 값으로 상당히 큰 배열에 대해 해시 코드를 1:1 대응이 되도록 만들기엔 한계가 있으므로 충돌이 납니다. 그러므로 `Collision` 해결은 필수이며 그 방법들에 대해 알아보겠습니다.

충돌을 해결하는 데 여러 가지 방법이 있습니다. 그 중 기본이 되는 `Open Address`과 `Separate Chaining` 방식에 대해 알아보겠습니다.

### Separate Chaining 방식 (분리 연결법)
충돌이 발생하면 `Linked List`를 사용해 저장하는 방식입니다.