### 1. doctype은 무엇을 합니까?

`DOCTYPE`은 사용 중인 HTML의 문서 유형과 버전을 선언합니다. 이는 문서가 어떤 버전의 HTML 또는 XHTML을 사용하고 있는지 브라우저에 알려주어 브라우저가 콘텐츠를 올바르게 렌더링하도록 돕는 방법입니다. HTML 문서의 맨 처음에 배치됩니다.

### 알아두면 좋은 정보:

'DOCTYPE'을 지정하지 않으면 브라우저가 HTML을 '쿼크 모드'로 렌더링할 수 있으며, 이로 인해 여러 브라우저에서 모양이 일관되지 않을 수 있습니다.

### 2. 표준 모드와 쿼크 모드의 차이점은 무엇인가요?

**표준 모드**: 브라우저는 W3C 사양에 따라 페이지를 렌더링합니다. 렌더링은 공식 HTML 및 CSS 사양과 일치합니다.

**Quirks Mode**: 브라우저는 이전 브라우저의 동작을 모방하여 일관성 없는 렌더링이 발생할 수 있습니다. 웹 표준이 확고하게 확립되지 않았던 시대로 되돌아가는 것입니다.

### 알아두면 좋은 정보:

웹이 발전하면서 오래된 웹사이트가 확립된 표준을 따르지 않는 경우가 있었습니다. 이러한 사이트가 깨지는 것을 방지하기 위해 브라우저에는 **Quirks Mode**가 도입되었습니다.

### 3. XML과 XHTML의 차이점은 무엇인가요?

**XML(eXtensible Markup Language)**: 사람과 기계 모두가 읽을 수 있는 형식으로 문서를 인코딩하기 위한 규칙을 정의하는 언어입니다. HTML을 대체하는 것이 아니라 보완하는 것입니다.

**XHTML(eXtensible Hypertext Markup Language)**: HTML을 XML 애플리케이션으로 재구성한 것입니다. 본질적으로 HTML의 더 엄격하고 깔끔한 버전입니다.

### 알아두면 좋은 정보:

둘 다 마크업 언어이지만 XML은 데이터 구조화에 중점을 두는 반면, XHTML은 HTML과 XML의 엄격한 규칙을 혼합하여 웹 콘텐츠를 표시하는 데 중점을 둡니다.

### 4. XHTML을 사용하는 페이지의 제한 사항은 무엇입니까?

- **더 엄격한 구문**: HTML과 달리 XHTML에서는 모든 요소가 적절하게 닫히고 중첩되어야 합니다.
- **덜 관대함**: 일반적으로 오류가 있는 페이지를 표시하는 HTML과 달리 XHTML 문서에 작은 실수가 있는 경우 브라우저는 오류를 표시합니다.
- **복잡성**: 간단한 웹 페이지의 경우 XHTML은 과잉으로 보일 수 있으며 불필요한 복잡성을 초래할 수 있습니다.

### 알아두면 좋은 정보:

XHTML은 XML의 엄격함을 웹 콘텐츠에 적용하기 위해 도입되었지만 이러한 엄격함은 때로는 개발 시 문제를 야기할 수 있습니다.

### 5. & 6. 다국어 페이지를 제공하는 방법과 다국어 페이지 제공 방법을 설명하는 방법은 무엇입니까?

- **`lang` 속성 사용**: `<html>` 태그에 `lang` 속성을 지정하면 전체 문서의 언어를 설정할 수 있습니다.
- **콘텐츠 협상**: 서버는 사용자의 `Accept-Language` HTTP 헤더를 기반으로 다른 버전의 페이지를 보냅니다.
- **언어별로 별도의 URL**: 일부 웹사이트는 언어별 하위 도메인이나 폴더(예: `en.example.com` 또는 `example.com/fr/`)를 선택합니다.
- **CMS 사용**: 많은 콘텐츠 관리 시스템은 번역이 적절하게 저장되고 제공되는 다국어 지원을 제공합니다.

### 알아두면 좋은 정보:

여러 언어로 콘텐츠를 제공하면 웹사이트의 잠재 고객을 크게 늘릴 수 있습니다. 모든 경우에 적용되는 일률적인 솔루션은 없으며 사용되는 방법은 웹 사이트의 특정 요구 사항과 인프라에 따라 달라지는 경우가 많습니다.

### 7. data-* 속성은 어떤 역할을 합니까? 그것을 사용하면 어떤 이점이 있습니까?

`data-*` 속성을 사용하면 페이지나 애플리케이션에만 맞춤 데이터를 저장할 수 있습니다. 기본 속성이 없는 사용자 정의 데이터를 저장하기 위한 것입니다.

### 알아두면 좋은 정보:

주요 이점은 의미가 없는 요소나 속성에 의존하지 않고 마크업에 직접 추가 정보를 포함할 수 있다는 것입니다. JavaScript를 통해 데이터에 쉽게 액세스할 수 있게 하여 프런트엔드에서의 상호 작용을 촉진합니다.

### 8. HTML5를 개방형 웹 플랫폼이라고 생각한다면 HTML5는 무엇으로 구성되어 있나요?

HTML5는 단지 새로운 마크업 요소에 관한 것이 아닙니다. 여기에는 다음을 포함하여 더 광범위한 기술, 사양 및 API가 포함됩니다.

- **의미**: `<header>`, `<footer>` 및 `<article>`과 같은 새로운 요소.
- **연결성**: 실시간 통신을 위한 WebSocket과 같은 API입니다.
- **오프라인 및 저장소**: `localStorage` 및 `sessionStorage` 소개.
- **멀티미디어**: `<audio>` 및 `<video>`와 같은 요소.
- **2D/3D 그래픽 및 효과**: Canvas, WebGL 및 CSS3 변환.
- **성능 및 통합**: 백그라운드 처리를 위한 웹 작업자.
- **기기 액세스**: 위치정보, 터치 이벤트 등
- **스타일링**: 고급 CSS3 스타일.

### 알아두면 좋은 정보:

HTML5는 웹 개발에 혁명을 일으켰고, 풍부하고 상호작용적이며 멀티미디어 기반의 웹 애플리케이션을 만드는 데 더욱 강력한 플랫폼이 되었습니다.

### 9. 쿠키, 세션스토리지, 로컬스토리지의 차이점을 설명해 주세요.

### 쿠키:

쿠키는 브라우저가 사용자 기기에 저장하는 작은 데이터 조각으로, 일반적으로 상태 저장 정보를 기억하거나 사용자의 탐색 활동을 추적하는 데 사용됩니다.

**특징**:

- **크기 제한**: 쿠키에는 쿠키당 약 4KB의 크기 제한이 있습니다.
- **수명**: 쿠키는 세션 기반(브라우저를 닫으면 제거됨)이거나 지속적(지정된 만료 날짜까지 지속)일 수 있습니다.
- **보안**: 보안 쿠키는 보안 HTTPS 연결을 통해서만 전송되도록 설정할 수 있습니다.
- **범위**: 쿠키의 범위는 특정 도메인 및 경로로 지정되어 쿠키가 전송되는 위치를 제한할 수 있습니다.
- **HTTP 전용**: HTTP 전용 쿠키는 JavaScript를 통해 액세스할 수 없으므로 XSS(교차 사이트 스크립팅) 공격을 방지하는 데 도움이 됩니다.
- **전송**: 쿠키는 모든 HTTP 요청과 함께 연결된 도메인으로 전송되므로 전송되는 데이터 양이 증가하고 잠재적으로 성능에 영향을 줄 수 있습니다.

**사용 사례**:

- 사용자 인증: 세션 전반에 걸쳐 사용자의 로그인 상태를 유지합니다.
- 세션 추적: 세션 중 사용자 활동을 식별합니다.
- 개인화: 맞춤형 경험을 위한 사용자 기본 설정을 저장합니다.

### 세션저장소:

웹 저장소 API의 일부인 `sessionStorage`를 사용하면 웹 페이지가 페이지 세션 동안에만 데이터가 유지되는 키-값 쌍을 웹 브라우저에 저장할 수 있습니다.

**특징**:

- **크기 제한**: 브라우저에 따라 일반적으로 약 5-10MB의 데이터가 허용됩니다.
- **평생**: 페이지 세션 기간 동안에만 데이터를 사용할 수 있습니다. 탭이나 창을 닫으면 지워집니다.
- **범위**: `sessionStorage`에 저장된 데이터는 단일 페이지의 세션에만 적용되므로 다른 탭이나 창에서는 액세스할 수 없습니다.
- **격리**: 쿠키와 달리 모든 HTTP 요청과 함께 데이터가 자동으로 전송되지 않습니다.

**사용 사례**:

- 양식 데이터를 임시로 저장합니다.
- 단일 세션에 대한 설정과 같은 임시 상태를 저장합니다.

### 로컬스토리지:

또한 웹 저장소 API의 일부인 'localStorage'를 사용하면 웹 페이지가 웹 브라우저에 키-값 쌍을 저장할 수 있으며 브라우저가 닫힌 후에도 데이터가 유지됩니다.

**특징**:

- **크기 제한**: `sessionStorage`와 마찬가지로 `localStorage`는 일반적으로 약 5-10MB의 데이터를 허용합니다.
- **수명**: `sessionStorage`와 달리 데이터는 지속적이고 브라우저가 닫혀도 계속 저장됩니다.
- **범위**: 'localStorage'에 저장된 데이터에는 만료 시간이 없으며 세션과 탭/창 전체에서 액세스할 수 있지만 범위는 특정 도메인으로 지정됩니다.
- **격리**: `sessionStorage`와 마찬가지로 모든 HTTP 요청과 함께 데이터가 자동으로 전송되지 않습니다.

**사용 사례**:

- 세션 간 사용자 기본 설정 또는 설정을 저장합니다.
- 오프라인 사용 또는 더 빠른 후속 페이지 로드를 위해 데이터를 캐싱합니다.

### 비교:

- **지속성**: 쿠키는 세션 기반이거나 정의된 수명을 가질 수 있습니다. `sessionStorage`는 페이지 세션 동안에만 지속됩니다. `localStorage`는 명시적으로 삭제될 때까지 지속됩니다.
- **크기**: 쿠키는 4KB로 제한되는 반면 `sessionStorage`와 `localStorage`는 일반적으로 5~10MB의 데이터를 저장할 수 있습니다.
- **보안**: 쿠키는 보안 또는 HTTP 전용으로 표시될 수 있지만 모든 HTTP 요청과 함께 전송되어 잠재적으로 데이터를 노출할 수도 있습니다. `sessionStorage` 및 `localStorage` 데이터는 브라우저에 남아 있으며 HTTP 요청과 함께 전송되지 않습니다.
- **사용법**: 쿠키는 인증 토큰과 같이 서버로 전송해야 하는 데이터에 더 적합합니다. `sessionStorage` 및 `localStorage`는 클라이언트 측 저장소 요구 사항에 더 적합합니다.

### 간단한 요약

**쿠키**:

- 클라이언트에 저장된 데이터는 모든 HTTP 요청과 함께 전송되며 성능에 영향을 미칠 수 있습니다.
- 쿠키당 약 4KB로 제한됩니다.
- 유효기간이 있을 수 있습니다.

**세션스토리지**:

- 더 큰 데이터 저장 공간을 허용합니다(브라우저에 따라 약 5-10MB).
- 데이터는 페이지 세션 동안에만 사용할 수 있습니다(탭을 닫으면 데이터가 삭제됩니다).

**로컬스토리지**:

- `sessionStorage`와 유사하게 더 큰 데이터 저장 공간을 허용합니다.
- 데이터는 지속적이고 브라우저가 종료되어도 유지됩니다.



### 10. IndexedDB와 IndexedDB와 웹 스토리지의 차이점:

**IndexedDB**:

- **정의**: IndexedDB는 상당한 양의 구조화된 데이터를 클라이언트 측에 저장하기 위한 낮은 수준의 트랜잭션 데이터베이스 시스템입니다. 기본 키를 사용하여 객체(파일/BLOB 포함)를 저장하고 검색할 수 있습니다.
    
- **장점**:
    
    - 많은 양의 데이터를 처리할 수 있습니다.
    - 거래를 지원합니다.
    - 효율적인 검색 기능을 갖춘 키-값 저장소를 제공합니다.

**IndexedDB와 웹 저장소의 차이점**:

- **데이터 제한**: 웹 저장소(localStorage 및 sessionStorage)는 더 작은 데이터 세트(문자열로만 제한되고 일반적으로 크기는 5-10MB)용으로 설계된 반면, IndexedDB는 복잡한 JavaScript 개체를 포함하여 더 큰 데이터 세트를 저장하도록 설계되었습니다.
- **구조**: 웹 저장소는 키-값 쌍으로 더 간단한 반면, IndexedDB는 트랜잭션, 인덱싱, 커서 탐색과 같은 더 복잡한 기능을 제공합니다.

### 11. `<script>`, `<script async>` 및 `<script defer>`의 차이점:

- **`<script>`**: 스크립트를 가져와서 실행하고 완료할 때까지 HTML 구문 분석을 차단합니다. 스크립트가 크거나 네트워크가 느린 경우 성능 문제가 발생할 수 있습니다.
- **`<script async>`**: HTML 구문 분석을 차단하지 않습니다. 스크립트는 비동기식으로 가져오고 일단 사용 가능해지면 HTML 파서가 일시 중지되어 스크립트를 실행한 다음 다시 시작됩니다.
- **`<script defer>`**: HTML 구문 분석을 차단하지 않습니다. 스크립트는 비동기식으로 가져오지만 HTML이 구문 분석된 후에만 실행됩니다. 문서에 나타나는 스크립트의 순서를 유지합니다.

### 12. CSS 및 JS 배치:

- **`<head>`의 CSS(`<link>`)**: 일반적으로 문서의 `<head>`에 스타일을 배치하는 것이 가장 좋습니다. 이렇게 하면 "FOUC(스타일이 지정되지 않은 콘텐츠 플래시)"가 발생할 수 있는 스타일이 지정되지 않은 콘텐츠가 사용자에게 표시되지 않습니다.
- **`<body>` 뒤의 JS(`<script>`)**: 닫는 `</body>` 태그 바로 앞에 스크립트를 배치하면 스크립트가 실행되기 전에 DOM이 완전히 구성되어 오류 가능성이 줄어듭니다. 페이지 렌더링을 차단하는 것을 방지합니다. 그러나 'async' 또는 'defer'를 사용하면 위치가 덜 중요해집니다.

### 13. 프로그레시브 렌더링:

프로그레시브 렌더링은 전체 페이지가 로드될 때까지 기다리지 않고 콘텐츠를 덩어리로 렌더링하는 프로세스입니다. 이 접근 방식은 인지된 성능과 사용자 경험을 향상시킬 수 있습니다. 기술에는 이미지의 지연 로딩, 보이는 콘텐츠(스크롤 없이 볼 수 있는 부분) 우선순위 지정, CSS/JS의 비동기 로딩이 포함됩니다.

### 14 `srcset` 속성:

`<img>` 태그의 `srcset`을 사용하면 개발자가 다양한 화면 해상도와 크기에 대해 여러 이미지 파일을 지정할 수 있습니다. 브라우저는 뷰포트 크기, 화면 해상도, 네트워크 상태 등 자체 기준에 따라 가장 적절한 이미지를 선택합니다.

**프로세스**:

- 브라우저는 장치의 화면 크기, 해상도 및 기타 기준을 평가합니다.
- `srcset`에 제공된 세트에서 가장 적절한 이미지를 선택합니다.
- 선택한 이미지가 다운로드되어 표시됩니다.

### 15. HTML templating language Handlebars:

**Handlebars**:

- **정의**: Handlebars는 데이터로 채워진 HTML을 생성하는 데 도움이 되는 널리 사용되는 템플릿 엔진입니다. 템플릿과 입력 개체를 사용하여 HTML 또는 기타 형식의 출력을 생성합니다.
    
- **개발자를 위한 이점**:
    
    - **관심사항 분리**: 프레젠테이션과 논리를 분리하여 유지합니다.
    - **재사용성**: 템플릿은 다양한 데이터 세트에서 재사용할 수 있습니다.
    - **클리너 코드**: 논리가 없는 템플릿을 사용하면 템플릿이 더 깔끔하고 이해하기 쉽습니다.

### 16. 버블링 및 캡처링:

- **버블링**: 요소에서 이벤트가 발생하면 먼저 해당 요소에 대한 핸들러를 실행한 다음 해당 상위 항목, 그런 다음 다른 상위 요소에 대해 계속해서 핸들러를 실행합니다. 이벤트가 가장 안쪽 요소에서 부모를 통해 "버블링"되기 때문에 이 프로세스를 "버블링"이라고 합니다.
- **캡처링**: 캡처는 이벤트가 요소까지 내려오는 단계입니다. 일부 이벤트는 버블링되지 않지만 모든 이벤트는 캡처 단계 중에 대상 요소로 가는 도중에 포착될 수 있습니다.

JavaScript에서는 `addEventListener`의 세 번째 인수를 사용하여 캡처 또는 버블링 단계에서 이벤트를 처리할지 결정할 수 있습니다. 'true'로 설정하면 캡처가 처리되고 'false'(기본값)는 버블링이 처리됩니다.

### 버블링은 기본적으로 자식에서 부모 엘리먼트로 이벤트가 전달되는 것을 말하는데 c => b => a 순으로 전달 되는 것을 b => a => c로 전달 되게 하려면 어떻게 해야 하나요?

